# -*- coding: utf-8 -*-
"""Analisis Numerico - Tarea #1 y codigos extras

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1S4bp22esyFG9RpaoiT3OAKwV2dmec2UJ

Metodo de Bisección
"""

import numpy as np

"""
This method finds an approximate root of a continuous function `func`
within an interval [a, b], provided that f(a) * f(b) < 0.
The guarantee comes from the Intermediate Value Theorem, which states:

"If f is continuous on [a, b], then there exists a point c ∈ [a, b]
where f(c) takes on all values between f(a) and f(b)."

As a particular result, if f(a) and f(b) have opposite signs
(and thus, f(a) * f(b) < 0) then there exists at least one c
such that f(c) = 0.

Parameters:
  - func = the function we're evaluating (function)
  - a = the beginning of the interval (float)
  - b = the end of the interval (float)
  - tol = the maximum error tolerance allowed (float)
  - max_iter = the maximum number of iterations allowed (int)

Returns:
  - c = the approximated value of the root (float)
  - If it isn't able to find one, it returns an error message (string)
"""

def bisection(func, a, b, tol, max_iter):
  if func(a)*func(b) >= 0: #Checks if the interval is valid
    return "Error: Interval is not valid for Bisection Method"

  for i in range(max_iter):
    c = (a+b)/2 #Bisects the interval
    if np.abs(func(c)) < tol:
      return c #If the value is under the tolerance threshold, it returns it as the approximate root.
    else:
      if func(c)*func(a) < 0: #Checks if the new interval [a,c] is valid. If so, he root lies within this interval.
        b = c
      else: #If [a,c] isn't valid, defaults the new interval [c,b]. It is valid because of tricotomy, thus, the root lies within this interval.
        a = c
  return "Error: Iterations exceeded"

"""Example cases"""
if __name__ == "__main__":

    tol = 10e-7
    max_iter = 100

    def f(x):
      return (x-1)*(x-3)*(x-4)

    root = bisection(f, 0, 5, tol, max_iter)

    print(f"f(x) = (x-1)(x-3)(x-4)")
    print(f"Aproximated root for f(x) = {root}")

    def g(x):
      return np.cos(np.sqrt(x**2))

    root = bisection(g, 1, 4, tol, max_iter)

    print(f"g(x) = cos(sqrt(x**2))")
    print(f"Aproximated root for g(x) = {root}")